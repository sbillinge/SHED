

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>shed.event_streams &mdash; SHED  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="SHED  documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> SHED
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../shed.html">shed package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SHED</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>shed.event_streams</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for shed.event_streams</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Stream functions (actually classes) for building pipelines for the Event</span>
<span class="sd">Model&quot;&quot;&quot;</span>
<span class="c1">##############################################################################</span>
<span class="c1">#</span>
<span class="c1"># xpdan            by Billinge Group</span>
<span class="c1">#                   Simon J. L. Billinge sb2896@columbia.edu</span>
<span class="c1">#                   (c) 2017 trustees of Columbia University in the City of</span>
<span class="c1">#                        New York.</span>
<span class="c1">#                   All rights reserved</span>
<span class="c1">#</span>
<span class="c1"># File coded by:    Christopher J. Wright (CJ-Wright)</span>
<span class="c1">#</span>
<span class="c1"># See AUTHORS.txt for a list of people who contributed.</span>
<span class="c1"># See LICENSE.txt for license information.</span>
<span class="c1">#</span>
<span class="c1">##############################################################################</span>
<span class="kn">import</span> <span class="nn">functools</span> <span class="k">as</span> <span class="nn">ft</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">zip</span> <span class="k">as</span> <span class="n">zzip</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">deque</span>

<span class="kn">from</span> <span class="nn">streamz.core</span> <span class="k">import</span> <span class="n">Stream</span><span class="p">,</span> <span class="n">no_default</span>
<span class="kn">from</span> <span class="nn">tornado.locks</span> <span class="k">import</span> <span class="n">Condition</span>
<span class="kn">import</span> <span class="nn">copy</span>


<span class="c1"># TODO: if mismatch includes error stop doc be more verbose</span>


<span class="k">def</span> <span class="nf">_update_initial_state_helper</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">attr_list</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">attr_list</span><span class="p">}</span>


<div class="viewcode-block" id="star"><a class="viewcode-back" href="../../shed.html#shed.event_streams.star">[docs]</a><span class="k">def</span> <span class="nf">star</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take tuple and unpack it into args&quot;&quot;&quot;</span>

    <span class="nd">@ft</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wraps</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wraps</span></div>


<div class="viewcode-block" id="dstar"><a class="viewcode-back" href="../../shed.html#shed.event_streams.dstar">[docs]</a><span class="k">def</span> <span class="nf">dstar</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Take dict and **kwargs and unpack both it as **kwargs&quot;&quot;&quot;</span>

    <span class="nd">@ft</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wraps</span><span class="p">(</span><span class="n">kwargs1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs2</span><span class="p">):</span>
        <span class="n">kwargs1</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wraps</span></div>


<div class="viewcode-block" id="istar"><a class="viewcode-back" href="../../shed.html#shed.event_streams.istar">[docs]</a><span class="k">def</span> <span class="nf">istar</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Inverse of star, take *args and turn into tuple&quot;&quot;&quot;</span>

    <span class="nd">@ft</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wraps</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wraps</span></div>


<div class="viewcode-block" id="EventStream"><a class="viewcode-back" href="../../shed.html#shed.event_streams.EventStream">[docs]</a><span class="k">class</span> <span class="nc">EventStream</span><span class="p">(</span><span class="n">Stream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; The EventStream class handles data of the form of an infinite</span>
<span class="sd">    sequence of events in the Event Model.</span>

<span class="sd">    In the Event model, the data-stream is a series of fortunate events.</span>
<span class="sd">    Each event consists of a name-document pair</span>
<span class="sd">    where the dictionary contains the data and metadata associated with the</span>
<span class="sd">    event.</span>
<span class="sd">    More information here:</span>
<span class="sd">    https://nsls-ii.github.io/architecture-overview.html</span>

<span class="sd">    EventStreams subscribe to each other passing and transforming data between</span>
<span class="sd">    them. An EventStream object listens for updates from upstream, reacts to</span>
<span class="sd">    these updates, and then emits more data to flow downstream to all</span>
<span class="sd">    EventStream objects that subscribe to it. Downstream EventStream objects</span>
<span class="sd">    may connect at any point of an EventStream graph to get a full view of the</span>
<span class="sd">    data coming off of that point to do with as they will.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    md : dict</span>
<span class="sd">        Each event stream has a Start document that contains metadata about</span>
<span class="sd">        the stream</span>
<span class="sd">    input_info : dict, optional</span>
<span class="sd">        Input info for an operation. Operations are callables that will apply</span>
<span class="sd">        operations to the data streams. Not always needed. The input_info</span>
<span class="sd">        provides a map between event data keys and the callable (function)</span>
<span class="sd">        args/kwargs.</span>
<span class="sd">        Note that the keys for `input_info` can either be strings or integers.</span>
<span class="sd">        If a string, then the data associated with the value will be mapped to</span>
<span class="sd">        that kwarg in the funciton. If an int then the data will be placed in</span>
<span class="sd">        the position in the args matching the numerical value.</span>

<span class="sd">    output_info : list of tuples, optional</span>
<span class="sd">        Output info from the operation, not needed for all cases</span>
<span class="sd">        This:</span>
<span class="sd">            Creates a map between function returns and event data keys</span>
<span class="sd">            Provides information for building a descriptor for the output</span>
<span class="sd">            event stream. Each event stream has a descriptor which contains</span>
<span class="sd">            information about what is in the events in the stream.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is intended as a base class for the stream functions (map, filter,</span>
<span class="sd">    etc.).</span>

<span class="sd">    Most implementations of the subclasses will:</span>
<span class="sd">    a) override update for flow control based classes</span>
<span class="sd">    b) override event for operator based classes</span>
<span class="sd">    c) override multiple document methods (see eventify) although this is rare</span>

<span class="sd">    It is important for the overridden document methods that the return</span>
<span class="sd">    follows the pattern of ``super().document_name(new_document)``. This way</span>
<span class="sd">    the EventStream properly issues the new document with its name and other</span>
<span class="sd">    needed internal flow control.</span>

<span class="sd">    Nodes clean themselves when the receive a start document (with a few</span>
<span class="sd">    exceptions, see BundleSingleStream).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># these are sacred kwargs which can never be passed to operator nodes</span>
    <span class="n">pop_kwargs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;output_info&#39;</span><span class="p">,</span> <span class="s1">&#39;input_info&#39;</span><span class="p">,</span> <span class="s1">&#39;md&#39;</span><span class="p">,</span> <span class="s1">&#39;stream_name&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;raise_upon_error&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span> <span class="n">output_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">input_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">md</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">stream_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">raise_upon_error</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the stream</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input_info: dict, optional</span>
<span class="sd">            describes the incoming streams by providing a map between function</span>
<span class="sd">            args/kwargs and data in each incoming stream. The form for this</span>
<span class="sd">            is ``{&#39;function_arg/kwarg_position/name&#39;:</span>
<span class="sd">            ((&#39;keys&#39;, &#39;to&#39;, &#39;data&#39;, &#39;in&#39;, &#39;dict&#39;), stream_number)}`` where</span>
<span class="sd">            the stream_number denotes which stream to pull the data from.</span>
<span class="sd">        output_info: list of tuples, optional</span>
<span class="sd">            describes the resulting stream</span>
<span class="sd">        md: dict, optional</span>
<span class="sd">            Additional metadata to be added to the run start document</span>

<span class="sd">        Notes</span>
<span class="sd">        ------</span>
<span class="sd">        input_info is designed to map keys in streams to kwargs in functions.</span>
<span class="sd">        It is critical for the internal data from the events to be returned,</span>
<span class="sd">        upon `event_contents`.</span>
<span class="sd">        input_info = {&#39;input_kwarg&#39;: (&#39;data_key&#39;, stream_number)}</span>
<span class="sd">        Note that the stream number is assumed to be zero if not specified</span>

<span class="sd">        output_info is designed to take the output tuple and map it back into</span>
<span class="sd">        data_keys.</span>
<span class="sd">        output_info = [(&#39;data_key&#39;, {&#39;dtype&#39;: &#39;array&#39;, &#39;source&#39;: &#39;testing&#39;})]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">md</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">md</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">stream_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">md</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">stream_name</span><span class="o">=</span><span class="n">stream_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;stream_name&#39;</span> <span class="ow">in</span> <span class="n">md</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream_name</span> <span class="o">=</span> <span class="n">md</span><span class="p">[</span><span class="s1">&#39;stream_name&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream_name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">Stream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">stream_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stream_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">output_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_info</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">input_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">input_info</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parent_uids</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outbound_descriptor_uid</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">md</span> <span class="o">=</span> <span class="n">md</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">md</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_info</span> <span class="o">=</span> <span class="n">output_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_info</span> <span class="o">=</span> <span class="n">input_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raise_upon_error</span> <span class="o">=</span> <span class="n">raise_upon_error</span>

        <span class="c1"># TODO: need multiple counters for multiple descriptors</span>
        <span class="c1"># This will need to be a dict with keys of descriptor names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_start_uid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">provenance</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bypass</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">excep</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># If the stream number is not specified its zero</span>
        <span class="c1"># FIXME: handle (nested tuple) so that it behaves properly</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">input_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">input_info</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Stream</span><span class="p">):</span>
                <span class="n">input_info</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># Build dict of initial state to clear upon new start, maybe</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state</span> <span class="o">=</span> <span class="n">_update_initial_state_helper</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="p">[</span><span class="s1">&#39;stream_name&#39;</span><span class="p">,</span>
             <span class="s1">&#39;parent_uids&#39;</span><span class="p">,</span>
             <span class="s1">&#39;outbound_descriptor_uid&#39;</span><span class="p">,</span>
             <span class="s1">&#39;md&#39;</span><span class="p">,</span>
             <span class="s1">&#39;output_info&#39;</span><span class="p">,</span>
             <span class="s1">&#39;input_info&#39;</span><span class="p">,</span>
             <span class="s1">&#39;i&#39;</span><span class="p">,</span>
             <span class="s1">&#39;run_start_uid&#39;</span><span class="p">,</span>
             <span class="s1">&#39;bypass&#39;</span><span class="p">,</span>
             <span class="s1">&#39;excep&#39;</span>
             <span class="p">]</span>
        <span class="p">)</span>

<div class="viewcode-block" id="EventStream.emit"><a class="viewcode-back" href="../../shed.html#shed.event_streams.EventStream.emit">[docs]</a>    <span class="k">def</span> <span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Push data into the stream at this point</span>

<span class="sd">        Events will not automatically propagate down a stream unless they are</span>
<span class="sd">        emitted, so for example, one could take every second event returned</span>
<span class="sd">        from a node function and emit it into a subsampled output stream.</span>
<span class="sd">        (for this specific example see ``filter``)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curate_streams</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">element</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">result</span> <span class="k">if</span> <span class="n">element</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>

<div class="viewcode-block" id="EventStream.dispatch"><a class="viewcode-back" href="../../shed.html#shed.event_streams.EventStream.dispatch">[docs]</a>    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dispatch to methods expecting particular doc types.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nds: tuple</span>
<span class="sd">            Name document pair</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple:</span>
<span class="sd">            New name document pair</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curate_streams</span><span class="p">(</span><span class="n">nds</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)(</span><span class="n">docs</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventStream.update"><a class="viewcode-back" href="../../shed.html#shed.event_streams.EventStream.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Emit the new name document pair</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x: tuple</span>
<span class="sd">            Name document pair</span>
<span class="sd">        who: stream instance, optional</span>
<span class="sd">            This is mostly used internally for emit</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list:</span>
<span class="sd">            The list of issued documents, used for back pressure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></div>

<div class="viewcode-block" id="EventStream.curate_streams"><a class="viewcode-back" href="../../shed.html#shed.event_streams.EventStream.curate_streams">[docs]</a>    <span class="k">def</span> <span class="nf">curate_streams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nds</span><span class="p">,</span> <span class="n">outbound</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Standardize inbound/outbound name document pairs</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nds: tuple, or tuple of tuples</span>
<span class="sd">            The name document pair(s)</span>
<span class="sd">        outbound: bool</span>
<span class="sd">            If True curate streams outbound</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        name: str</span>
<span class="sd">            The name of the output doc(s)</span>
<span class="sd">        docs: tuple or dict</span>
<span class="sd">            The document(s)</span>

<span class="sd">        Notes</span>
<span class="sd">        ------</span>
<span class="sd">        If we get multiple streams make (name, (doc, doc, doc, ...))</span>
<span class="sd">        Otherwise (name, (doc,))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if there are multiple streams</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">names</span><span class="p">,</span> <span class="n">docs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">zzip</span><span class="p">(</span><span class="o">*</span><span class="n">nds</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Misaligned Streams&#39;</span><span class="p">)</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">newdocs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">:</span>
                <span class="c1"># for case of ((name, ({}, {})), (name, ({}, {})))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">newdocs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newdocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

            <span class="n">docs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">newdocs</span><span class="p">)</span>

        <span class="c1"># if only one stream</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names</span><span class="p">,</span> <span class="n">docs</span> <span class="o">=</span> <span class="n">nds</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">names</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">docs</span> <span class="o">=</span> <span class="p">(</span><span class="n">docs</span><span class="p">,)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">outbound</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">docs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">docs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">docs</span> <span class="o">=</span> <span class="n">docs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">docs</span></div>

<div class="viewcode-block" id="EventStream.generate_provenance"><a class="viewcode-back" href="../../shed.html#shed.event_streams.EventStream.generate_provenance">[docs]</a>    <span class="k">def</span> <span class="nf">generate_provenance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate provenance information about the stream function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func: callable</span>
<span class="sd">            The function used inside the stream class (see map, filter, etc.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">stream_class</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">stream_class_module</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
            <span class="c1"># TODO: Need to support pip and other sources at some point</span>
            <span class="c1"># conda_list=subprocess.check_output([&#39;conda&#39;, &#39;list&#39;,</span>
            <span class="c1">#                                     &#39;-e&#39;]).decode()</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_info</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">input_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_info</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_info</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">output_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">output_info</span><span class="p">)</span>

        <span class="c1"># TODO: support partials?</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Get all the callables and put them as their own dict inside the main</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">function_module</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span>
                            <span class="c1"># this line gets more complex with classes</span>
                            <span class="n">function_name</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">)</span>
        <span class="n">full_event</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;full_event&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">full_event</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">full_event</span><span class="o">=</span><span class="n">full_event</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">provenance</span> <span class="o">=</span> <span class="n">d</span></div>

<div class="viewcode-block" id="EventStream.start"><a class="viewcode-back" href="../../shed.html#shed.event_streams.EventStream.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Issue new start document for input documents</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        docs: tuple of dicts or dict</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        name: &#39;start&#39;</span>
<span class="sd">        doc: dict</span>
<span class="sd">            The document</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># When we get a start document reset to the initial status</span>
        <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_start_uid</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_uids</span> <span class="o">=</span> <span class="p">[</span><span class="n">doc</span><span class="p">[</span><span class="s1">&#39;uid&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">docs</span> <span class="k">if</span> <span class="n">doc</span><span class="p">]</span>
        <span class="n">new_start_doc</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">uid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run_start_uid</span><span class="p">,</span>
                             <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">md</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bypass</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="n">new_start_doc</span></div>

<div class="viewcode-block" id="EventStream.descriptor"><a class="viewcode-back" href="../../shed.html#shed.event_streams.EventStream.descriptor">[docs]</a>    <span class="k">def</span> <span class="nf">descriptor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Issue new descriptor document for input documents</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        docs: tuple of dicts or dict</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        name: &#39;descriptor&#39;</span>
<span class="sd">        doc: dict</span>
<span class="sd">            The document</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bypass</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_start_uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream_name</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">md</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Received EventDescriptor before &quot;</span>
                                   <span class="s2">&quot;RunStart.&quot;</span><span class="p">)</span>
            <span class="c1"># If we had to describe the output information then we need an</span>
            <span class="c1"># all new descriptor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outbound_descriptor_uid</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
            <span class="n">new_descriptor</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">uid</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outbound_descriptor_uid</span><span class="p">,</span>
                                  <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span>
                                  <span class="n">run_start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run_start_uid</span><span class="p">,</span>
                                  <span class="n">name</span><span class="o">=</span><span class="s1">&#39;primary&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_info</span><span class="p">:</span>
                <span class="n">new_descriptor</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="n">data_keys</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_info</span><span class="p">})</span>

            <span class="c1"># no truly new data needed</span>
            <span class="c1"># XXX: giant hack only look at the keys because () != []</span>
            <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;data_keys&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">==</span> <span class="n">docs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;data_keys&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                     <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">):</span>
                <span class="n">new_descriptor</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data_keys</span><span class="o">=</span><span class="n">docs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;data_keys&#39;</span><span class="p">])</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">rdocs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">docs</span><span class="p">)</span>
                <span class="n">rdocs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">dk</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">rdocs</span><span class="p">:</span>
                    <span class="n">dk</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">doc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;data_keys&#39;</span><span class="p">))</span>
                <span class="n">new_descriptor</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data_keys</span><span class="o">=</span><span class="n">dk</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="s1">&#39;descriptor&#39;</span><span class="p">,</span> <span class="n">new_descriptor</span></div>

<div class="viewcode-block" id="EventStream.event"><a class="viewcode-back" href="../../shed.html#shed.event_streams.EventStream.event">[docs]</a>    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Issue event document for input documents</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        docs: tuple of dicts or dict</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        name: &#39;event&#39;</span>
<span class="sd">        doc: dict</span>
<span class="sd">            The document</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bypass</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;event&#39;</span><span class="p">,</span> <span class="n">docs</span></div>

<div class="viewcode-block" id="EventStream.stop"><a class="viewcode-back" href="../../shed.html#shed.event_streams.EventStream.stop">[docs]</a>    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Issue new stop document</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        docs: tuple of dicts or dict or Exception</span>
<span class="sd">            If Exception issue a stop which notes the failure</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        name: &#39;stop&#39;</span>
<span class="sd">        doc: dict</span>
<span class="sd">            The document</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bypass</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_start_uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Received RunStop before RunStart.&quot;</span><span class="p">)</span>
            <span class="n">new_stop</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">uid</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()),</span>
                            <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span>
                            <span class="n">run_start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">run_start_uid</span><span class="p">,</span>
                            <span class="n">provenance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">provenance</span><span class="p">,</span>
                            <span class="n">parents</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parent_uids</span><span class="p">,</span>
                            <span class="n">md</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">md</span>
                            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bypass</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR REPORT=======================&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream_name</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">md</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">())</span>
                <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">docs</span><span class="p">))</span>

                <span class="n">new_stop</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">reason</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="n">docs</span><span class="p">),</span>
                                <span class="n">trace</span><span class="o">=</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">(),</span>
                                <span class="n">exit_status</span><span class="o">=</span><span class="s1">&#39;failure&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">excep</span> <span class="o">=</span> <span class="n">docs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_stop</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">exit_status</span><span class="o">=</span><span class="s1">&#39;success&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;stop&#39;</span><span class="p">,</span> <span class="n">new_stop</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">raise_upon_error</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">excep</span><span class="p">:</span>
            <span class="k">raise</span> <span class="bp">self</span><span class="o">.</span><span class="n">excep</span></div>

<div class="viewcode-block" id="EventStream.doc_contents"><a class="viewcode-back" href="../../shed.html#shed.event_streams.EventStream.doc_contents">[docs]</a>    <span class="k">def</span> <span class="nf">doc_contents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">,</span> <span class="n">full_event</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide some of the event data as a dict, which may be used as kwargs</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        docs: tuple of dicts</span>
<span class="sd">        full_event: bool, optional</span>
<span class="sd">            If True expose the data from full event, else only expose data</span>
<span class="sd">            from the &#39;data&#39; dictionary inside the event, defaults to False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        args: tuple</span>
<span class="sd">            The arguments to be passed to a function</span>
<span class="sd">        kwargs: dict</span>
<span class="sd">            The keyword arguments to be passed to a function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: access to full document(s)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_info</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># Reverse the order of the docs so that the first doc in resolves</span>
            <span class="c1"># last</span>
            <span class="n">rdocs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">docs</span><span class="p">)</span>
            <span class="n">rdocs</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">full_event</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">rdocs</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">doc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">rdocs</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">**</span><span class="n">doc</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># address inner dicts, not just data or everything</span>
            <span class="k">for</span> <span class="n">input_kwarg</span><span class="p">,</span> <span class="p">(</span><span class="n">data_key</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_info</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">inner</span> <span class="o">=</span> <span class="n">docs</span><span class="p">[</span><span class="n">position</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">dk</span> <span class="ow">in</span> <span class="n">data_key</span><span class="p">:</span>
                        <span class="n">inner</span> <span class="o">=</span> <span class="n">inner</span><span class="p">[</span><span class="n">dk</span><span class="p">]</span>
                <span class="c1"># for backwards compat will be removed soon</span>
                <span class="k">elif</span> <span class="n">full_event</span><span class="p">:</span>
                    <span class="n">inner</span> <span class="o">=</span> <span class="n">docs</span><span class="p">[</span><span class="n">position</span><span class="p">][</span><span class="n">data_key</span><span class="p">]</span>
                    <span class="ne">DeprecationWarning</span><span class="p">(</span><span class="s1">&#39;full_event will be removed in the &#39;</span>
                                       <span class="s1">&#39;near future please just use an empty &#39;</span>
                                       <span class="s1">&#39;data_key tuple&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">inner</span> <span class="o">=</span> <span class="n">docs</span><span class="p">[</span><span class="n">position</span><span class="p">][</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">data_key</span><span class="p">]</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">input_kwarg</span><span class="p">]</span> <span class="o">=</span> <span class="n">inner</span>

        <span class="n">args_positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]</span>
        <span class="n">args_positions</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="n">n_args</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args_positions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args_positions</span> <span class="ow">and</span> <span class="p">(</span><span class="n">args_positions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">n_args</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">or</span>
                               <span class="n">args_positions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">errormsg</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;Error, arguments supplied must be a set of integers</span>
<span class="s2">            ranging from 0 to number of arguments</span><span class="se">\n</span><span class="s2"></span>
<span class="s2">            Got </span><span class="si">{}</span><span class="s2"> instead&quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">args_positions</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errormsg</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">args_positions</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span></div>

<div class="viewcode-block" id="EventStream.issue_event"><a class="viewcode-back" href="../../shed.html#shed.event_streams.EventStream.issue_event">[docs]</a>    <span class="k">def</span> <span class="nf">issue_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new event document based off of function returns</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outputs: tuple, dict, or other</span>
<span class="sd">            Data returned from some external functon</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_event: dict</span>
<span class="sd">            The new event</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If the outputs of the function is an exception no event will be</span>
<span class="sd">        created, but a stop document will be issued.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bypass</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_start_uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Received Event before RunStart.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>

            <span class="c1"># Make a new event with no data</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_info</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span><span class="n">outputs</span><span class="p">,)</span>

            <span class="n">new_event</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">uid</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()),</span>
                             <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span>
                             <span class="n">timestamps</span><span class="o">=</span><span class="p">{},</span>
                             <span class="n">descriptor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outbound_descriptor_uid</span><span class="p">,</span>
                             <span class="n">filled</span><span class="o">=</span><span class="p">{</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="kc">True</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_info</span><span class="p">},</span>
                             <span class="n">seq_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">)</span>

            <span class="c1"># if output_info is not empty dict</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_info</span><span class="p">:</span>
                <span class="n">new_event</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">{</span><span class="n">output_name</span><span class="p">:</span> <span class="n">output</span>
                                       <span class="k">for</span> <span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">desc</span><span class="p">),</span> <span class="n">output</span> <span class="ow">in</span>
                                       <span class="n">zzip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_info</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">outputs</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;outputs not dict! raising  a type errror&#39;</span><span class="p">)</span>
                    <span class="n">errormsg</span> <span class="o">=</span> <span class="s2">&quot;Error, outputs is not a dict. Can&#39;t continue</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">errormsg</span> <span class="o">+=</span> <span class="s2">&quot;This typically comes from a function</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">errormsg</span> <span class="o">+=</span> <span class="s2">&quot;whose output is not nothing or a dict.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">errormsg</span> <span class="o">+=</span> <span class="s2">&quot;When dealing with such outputs, please </span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="n">errormsg</span> <span class="o">+=</span> <span class="s2">&quot;use the output_info keyword argument.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">errormsg</span><span class="p">)</span>
                <span class="n">new_event</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">outputs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">new_event</span></div>

<div class="viewcode-block" id="EventStream.refresh_event"><a class="viewcode-back" href="../../shed.html#shed.event_streams.EventStream.refresh_event">[docs]</a>    <span class="k">def</span> <span class="nf">refresh_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new event with the same data, but new metadata</span>
<span class="sd">        (uid, timestamp, etc.)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        event: tuple, dict, or other</span>
<span class="sd">            The event document</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_event: dict</span>
<span class="sd">            A new event with the same core data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bypass</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_start_uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Received Event before RunStart.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

            <span class="n">new_event</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
            <span class="n">new_event</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">uid</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()),</span>
                                  <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">(),</span>
                                  <span class="n">timestamps</span><span class="o">=</span><span class="p">{},</span>
                                  <span class="n">seq_num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">i</span><span class="p">))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">new_event</span></div>

    <span class="k">def</span> <span class="nf">_clean_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop_kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear the state of the node</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">v</span><span class="p">))</span></div>


<div class="viewcode-block" id="map"><a class="viewcode-back" href="../../shed.html#shed.event_streams.map">[docs]</a><span class="k">class</span> <span class="nc">map</span><span class="p">(</span><span class="n">EventStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply a function onto every event in the stream</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func: callable</span>
<span class="sd">        The function to map on the event data</span>
<span class="sd">    child: EventStream instance</span>
<span class="sd">        The source of the data</span>
<span class="sd">    *args: tuple</span>
<span class="sd">        args to be passed to the function,</span>
<span class="sd">        which are appended to the args from `input_info`</span>
<span class="sd">    full_event: bool, optional</span>
<span class="sd">        If True expose the full event dict to the function, if False</span>
<span class="sd">        only expose the data from the event</span>
<span class="sd">    input_info: dict</span>
<span class="sd">        describe the incoming streams</span>
<span class="sd">    output_info: list of tuples</span>
<span class="sd">        describe the resulting stream</span>
<span class="sd">    **kwargs: dict</span>
<span class="sd">        kwargs to be passed to the function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from shed.utils import to_event_model</span>
<span class="sd">    &gt;&gt;&gt; from streamz import Stream</span>
<span class="sd">    &gt;&gt;&gt; import shed.event_streams as es</span>
<span class="sd">    &gt;&gt;&gt; a = [1, 2, 3]  # base data</span>
<span class="sd">    &gt;&gt;&gt; g = to_event_model(a, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; source = Stream()</span>
<span class="sd">    &gt;&gt;&gt; m = es.map(es.dstar(lambda x: x+5), source,</span>
<span class="sd">    ...     input_info={&#39;x&#39;: &#39;det&#39;},</span>
<span class="sd">    ...     output_info=[(&#39;res&#39;, {&#39;source&#39;: &#39;docstring&#39;, &#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; l = m.sink(print)</span>
<span class="sd">    &gt;&gt;&gt; L = m.sink_to_list()</span>
<span class="sd">    &gt;&gt;&gt; for doc in g: z = source.emit(doc)</span>
<span class="sd">    &gt;&gt;&gt; assert len(L) == 6</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span>
                 <span class="n">full_event</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">output_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">input_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

        <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">output_info</span><span class="o">=</span><span class="n">output_info</span><span class="p">,</span>
                             <span class="n">input_info</span><span class="o">=</span><span class="n">input_info</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_event</span> <span class="o">=</span> <span class="n">full_event</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_provenance</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">func</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_update_initial_state_helper</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;func_kwargs&#39;</span><span class="p">,</span> <span class="s1">&#39;func_args&#39;</span><span class="p">,</span> <span class="s1">&#39;full_event&#39;</span><span class="p">]))</span>

<div class="viewcode-block" id="map.event"><a class="viewcode-back" href="../../shed.html#shed.event_streams.map.event">[docs]</a>    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># we need to expose the event data</span>
            <span class="n">res_args</span><span class="p">,</span> <span class="n">res_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc_contents</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_event</span><span class="p">)</span>
            <span class="c1"># take the event contents and add them to the args/kwargs</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">res_args</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">func_args</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">res_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">func_kwargs</span><span class="p">)</span>
            <span class="c1"># Now we must massage the raw return into a new event</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">issue_event</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">event</span><span class="p">(</span><span class="n">result</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="filter"><a class="viewcode-back" href="../../shed.html#shed.event_streams.filter">[docs]</a><span class="k">class</span> <span class="nc">filter</span><span class="p">(</span><span class="n">EventStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Only pass through events that satisfy the predicate</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    predicate: callable</span>
<span class="sd">        The function which returns True if the event is to propagate</span>
<span class="sd">        further in the pipeline</span>
<span class="sd">    child: EventStream instance</span>
<span class="sd">        The source of the data</span>
<span class="sd">    *args: tuple</span>
<span class="sd">        args to be passed to the function,</span>
<span class="sd">        which are appended to the args from `input_info`</span>
<span class="sd">    input_info: dict</span>
<span class="sd">        describe the incoming streams</span>
<span class="sd">    full_event: bool, optional</span>
<span class="sd">        If True expose the full event dict to the predicate, if False</span>
<span class="sd">        only expose the data from the event</span>
<span class="sd">    document_name: {&#39;event&#39;, &#39;start&#39;, &#39;descriptor&#39;}, optional</span>
<span class="sd">        Which document to filter on, if event only pass events which meet the</span>
<span class="sd">        criteria. Otherwise if ``start`` only pass streams where the criteria</span>
<span class="sd">        is True in the start. Otherwise if ``descriptor`` only pass streams</span>
<span class="sd">        where the criteria is True in the descriptor. Defaults to &#39;event&#39;.</span>
<span class="sd">    **kwargs: dict</span>
<span class="sd">        kwargs to be passed to the function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from shed.utils import to_event_model</span>
<span class="sd">    &gt;&gt;&gt; from streamz import Stream</span>
<span class="sd">    &gt;&gt;&gt; import shed.event_streams as es</span>
<span class="sd">    &gt;&gt;&gt; a = [1, 2, 3]  # base data</span>
<span class="sd">    &gt;&gt;&gt; g = to_event_model(a, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; source = Stream()</span>
<span class="sd">    &gt;&gt;&gt; m = es.filter(lambda x: x&gt;1, source, input_info={&#39;x&#39;: &#39;det&#39;})</span>
<span class="sd">    &gt;&gt;&gt; l = m.sink(print)</span>
<span class="sd">    &gt;&gt;&gt; L = m.sink_to_list()</span>
<span class="sd">    &gt;&gt;&gt; for doc in g: z = source.emit(doc)</span>
<span class="sd">    &gt;&gt;&gt; assert len(L) == 5</span>

<span class="sd">    Filtering full headers</span>

<span class="sd">    &gt;&gt;&gt; from shed.utils import to_event_model</span>
<span class="sd">    &gt;&gt;&gt; from streamz import Stream</span>
<span class="sd">    &gt;&gt;&gt; import shed.event_streams as es</span>
<span class="sd">    &gt;&gt;&gt; a = [1, 2, 3]  # base data</span>
<span class="sd">    &gt;&gt;&gt; g = to_event_model(a, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; source = Stream()</span>
<span class="sd">    &gt;&gt;&gt; m = es.filter(lambda x: x[0][&#39;source&#39;] != &#39;to_event_model&#39;, source,</span>
<span class="sd">    ...     document_name=&#39;start&#39;)</span>
<span class="sd">    &gt;&gt;&gt; l = m.sink(print)</span>
<span class="sd">    &gt;&gt;&gt; L = m.sink_to_list()</span>
<span class="sd">    &gt;&gt;&gt; for doc in g: z = source.emit(doc)</span>
<span class="sd">    &gt;&gt;&gt; assert len(L) == 0</span>

<span class="sd">    Filtering on descriptors</span>

<span class="sd">    &gt;&gt;&gt; from shed.utils import to_event_model</span>
<span class="sd">    &gt;&gt;&gt; from streamz import Stream</span>
<span class="sd">    &gt;&gt;&gt; import shed.event_streams as es</span>
<span class="sd">    &gt;&gt;&gt; a = [1, 2, 3]  # base data</span>
<span class="sd">    &gt;&gt;&gt; g = to_event_model(a, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; source = Stream()</span>
<span class="sd">    &gt;&gt;&gt; m = es.filter(lambda x: x[0][&#39;name&#39;] != &#39;primary&#39;, source,</span>
<span class="sd">    ...     document_name=&#39;descriptor&#39;)</span>
<span class="sd">    &gt;&gt;&gt; l = m.sink(print)</span>
<span class="sd">    &gt;&gt;&gt; L = m.sink_to_list()</span>
<span class="sd">    &gt;&gt;&gt; for doc in g: z = source.emit(doc)</span>
<span class="sd">    &gt;&gt;&gt; assert len(L) == 2</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">predicate</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">input_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">full_event</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">document_name</span><span class="o">=</span><span class="s1">&#39;event&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize the node &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicate</span> <span class="o">=</span> <span class="n">predicate</span>

        <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">input_info</span><span class="o">=</span><span class="n">input_info</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clean_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">func_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_event</span> <span class="o">=</span> <span class="n">full_event</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">document_name</span> <span class="o">=</span> <span class="n">document_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">truth_value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Note we don&#39;t override event because with this update we don&#39;t see it</span>
        <span class="k">if</span> <span class="n">document_name</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_start_update</span>
        <span class="k">elif</span> <span class="n">document_name</span> <span class="o">==</span> <span class="s1">&#39;descriptor&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_descriptor_update</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor_truth_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_provenance</span><span class="p">(</span><span class="n">predicate</span><span class="o">=</span><span class="n">predicate</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_update_initial_state_helper</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;func_kwargs&#39;</span><span class="p">,</span> <span class="s1">&#39;func_args&#39;</span><span class="p">,</span> <span class="s1">&#39;full_event&#39;</span><span class="p">,</span> <span class="s1">&#39;document_name&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;truth_value&#39;</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_start_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># TODO: should we have something like event_contents for starts?</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curate_streams</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">res_args</span><span class="p">,</span> <span class="n">res_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc_contents</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_event</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">truth_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicate</span><span class="p">(</span><span class="o">*</span><span class="n">res_args</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">func_args</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="n">res_kwargs</span><span class="p">,</span>
                                                  <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">func_kwargs</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">docs</span><span class="p">)),</span>
                      <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">e</span><span class="p">))]</span>
                <span class="k">return</span> <span class="n">rv</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">truth_value</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">docs</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_descriptor_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curate_streams</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor_truth_values</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">docs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;descriptor&#39;</span><span class="p">:</span>
            <span class="c1"># TODO: we need to sort out how to deal with nodes/modes which only</span>
            <span class="c1"># take in singular headers vs multiple</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">descriptor_truth_values</span><span class="p">[</span><span class="n">docs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;uid&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicate</span><span class="p">(</span><span class="n">docs</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor_truth_values</span><span class="p">[</span><span class="n">docs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;uid&#39;</span><span class="p">]]:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;descriptor&#39;</span><span class="p">,</span> <span class="n">docs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;event&#39;</span> <span class="ow">and</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">descriptor_truth_values</span><span class="p">[</span><span class="n">docs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;descriptor&#39;</span><span class="p">]]):</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">event</span><span class="p">(</span><span class="n">docs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">docs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

<div class="viewcode-block" id="filter.event"><a class="viewcode-back" href="../../shed.html#shed.event_streams.filter.event">[docs]</a>    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="n">res_args</span><span class="p">,</span> <span class="n">res_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc_contents</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_event</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicate</span><span class="p">(</span><span class="o">*</span><span class="n">res_args</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">func_args</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">res_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">func_kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">event</span><span class="p">(</span><span class="n">doc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="accumulate"><a class="viewcode-back" href="../../shed.html#shed.event_streams.accumulate">[docs]</a><span class="k">class</span> <span class="nc">accumulate</span><span class="p">(</span><span class="n">EventStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Accumulate results with previous state</span>

<span class="sd">    This preforms running or cumulative reductions, applying the function</span>
<span class="sd">    to the previous total and the new element.  The function should take</span>
<span class="sd">    two arguments, the previous accumulated state and the next element and</span>
<span class="sd">    it should return a new accumulated state.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func: callable</span>
<span class="sd">        The function to map on the event data</span>
<span class="sd">    child: EventStream instance</span>
<span class="sd">        The source of the data</span>
<span class="sd">    state_key: str</span>
<span class="sd">        The keyword for current accumulated state in the func</span>
<span class="sd">    full_event: bool, optional</span>
<span class="sd">        If True expose the full event dict to the predicate, if False</span>
<span class="sd">        only expose the data from the event</span>
<span class="sd">    input_info: dict</span>
<span class="sd">        describe the incoming streams</span>
<span class="sd">        Note that only one key allowed since the func only takes two inputs</span>
<span class="sd">    output_info: list of tuples</span>
<span class="sd">        describe the resulting stream</span>
<span class="sd">    start: any or callable, optional</span>
<span class="sd">        Starting value for accumulation, if no_default use the event data</span>
<span class="sd">        dictionary, if callable run that callable on the event data, else</span>
<span class="sd">        use `start` as the starting data, defaults to no_default</span>
<span class="sd">    across_start: bool, optional</span>
<span class="sd">        If the accumulation should continue across multiple starts, defaults</span>
<span class="sd">        to False</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from shed.utils import to_event_model</span>
<span class="sd">    &gt;&gt;&gt; from streamz import Stream</span>
<span class="sd">    &gt;&gt;&gt; import shed.event_streams as es</span>
<span class="sd">    &gt;&gt;&gt; a = [1, 2, 3]  # base data</span>
<span class="sd">    &gt;&gt;&gt; g = to_event_model(a, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; source = Stream()</span>
<span class="sd">    &gt;&gt;&gt; m = es.accumulate(es.dstar(lambda a, b: a + b), source,</span>
<span class="sd">    ...     input_info={&#39;b&#39;: &#39;det&#39;},</span>
<span class="sd">    ...     output_info=[(&#39;res&#39;, {&#39;source&#39;: &#39;docstring&#39;, &#39;dtype&#39;: &#39;float&#39;})],</span>
<span class="sd">    ...     state_key=&#39;a&#39;)</span>
<span class="sd">    &gt;&gt;&gt; l = m.sink(print)</span>
<span class="sd">    &gt;&gt;&gt; L = m.sink_to_list()</span>
<span class="sd">    &gt;&gt;&gt; for doc in g: z = source.emit(doc)</span>
<span class="sd">    &gt;&gt;&gt; assert len(L) == 6</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">state_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">full_event</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">output_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">input_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">no_default</span><span class="p">,</span>
                 <span class="n">across_start</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_key</span> <span class="o">=</span> <span class="n">state_key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_state</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">input_info</span><span class="o">=</span><span class="n">input_info</span><span class="p">,</span>
                             <span class="n">output_info</span><span class="o">=</span><span class="n">output_info</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_info</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error : only one key allowed for accumulate&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">full_event</span> <span class="o">=</span> <span class="n">full_event</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">across_start</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_not_across_start_start</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_across_start_start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_provenance</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">func</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_update_initial_state_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                                <span class="p">[</span><span class="s1">&#39;state_key&#39;</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_not_across_start_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_state</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">docs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_across_start_start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="c1"># We want to store state so store it</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<div class="viewcode-block" id="accumulate.event"><a class="viewcode-back" href="../../shed.html#shed.event_streams.accumulate.event">[docs]</a>    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">doc</span><span class="p">):</span>
        <span class="c1"># TODO: can accumulate support args/kwargs?</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc_contents</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_event</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="ow">is</span> <span class="n">no_default</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># Note that there is only one input_info key allowed for this</span>
            <span class="c1"># stream function so this works</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_info</span><span class="o">.</span><span class="n">keys</span><span class="p">()))]</span>
        <span class="c1"># in case we need a bit more flexibility eg lambda x: np.empty(x.shape)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">state_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">event</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">issue_event</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="zip"><a class="viewcode-back" href="../../shed.html#shed.event_streams.zip">[docs]</a><span class="k">class</span> <span class="nc">zip</span><span class="p">(</span><span class="n">EventStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combine multiple streams together into a stream of tuples</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    children: EventStream instances</span>
<span class="sd">        The event streams to be zipped together</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from shed.utils import to_event_model</span>
<span class="sd">    &gt;&gt;&gt; from streamz import Stream</span>
<span class="sd">    &gt;&gt;&gt; import shed.event_streams as es</span>
<span class="sd">    &gt;&gt;&gt; from builtins import zip as zzip</span>
<span class="sd">    &gt;&gt;&gt; a = [1, 2, 3]  # base data</span>
<span class="sd">    &gt;&gt;&gt; b = [4, 5, 6]</span>
<span class="sd">    &gt;&gt;&gt; g = to_event_model(a, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; gg = to_event_model(b, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; source = Stream()</span>
<span class="sd">    &gt;&gt;&gt; source2 = Stream()</span>
<span class="sd">    &gt;&gt;&gt; m = es.zip(source, source2)</span>
<span class="sd">    &gt;&gt;&gt; l = m.sink(print)</span>
<span class="sd">    &gt;&gt;&gt; L = m.sink_to_list()</span>
<span class="sd">    &gt;&gt;&gt; for doc1, doc2 in zzip(g, gg):</span>
<span class="sd">    ...     z = source.emit(doc1),</span>
<span class="sd">    ...     zz = source2.emit(doc2)</span>
<span class="sd">    &gt;&gt;&gt; assert len(L) == 6</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;maxsize&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span> <span class="o">=</span> <span class="p">[</span><span class="n">deque</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">children</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="n">children</span><span class="p">)</span>

<div class="viewcode-block" id="zip.update"><a class="viewcode-back" href="../../shed.html#shed.event_streams.zip.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">who</span><span class="p">)]</span>
        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">)):</span>
                    <span class="c1"># If the docs don&#39;t match, preempt with prior good result</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">appendleft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prior</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">buf</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span> <span class="k">for</span> <span class="n">buf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">condition</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="o">=</span> <span class="n">tup</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">condition</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="Bundle"><a class="viewcode-back" href="../../shed.html#shed.event_streams.Bundle">[docs]</a><span class="k">class</span> <span class="nc">Bundle</span><span class="p">(</span><span class="n">EventStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combine multiple event streams into one</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    children: EventStream instances</span>
<span class="sd">        The event streams to be zipped together</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from shed.utils import to_event_model</span>
<span class="sd">    &gt;&gt;&gt; from streamz import Stream</span>
<span class="sd">    &gt;&gt;&gt; import shed.event_streams as es</span>
<span class="sd">    &gt;&gt;&gt; from builtins import zip as zzip</span>
<span class="sd">    &gt;&gt;&gt; a = [1, 2, 3]  # base data</span>
<span class="sd">    &gt;&gt;&gt; b = [4, 5, 6]</span>
<span class="sd">    &gt;&gt;&gt; g = to_event_model(a, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; gg = to_event_model(b, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; source = Stream()</span>
<span class="sd">    &gt;&gt;&gt; source2 = Stream()</span>
<span class="sd">    &gt;&gt;&gt; m = es.Bundle(source, source2)</span>
<span class="sd">    &gt;&gt;&gt; l = m.sink(print)</span>
<span class="sd">    &gt;&gt;&gt; L = m.sink_to_list()</span>
<span class="sd">    &gt;&gt;&gt; for doc1, doc2 in zzip(g, gg):</span>
<span class="sd">    ...     z = source.emit(doc1)</span>
<span class="sd">    ...     zz = source2.emit(doc2)</span>
<span class="sd">    &gt;&gt;&gt; assert len(L) == 9</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;maxsize&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span> <span class="o">=</span> <span class="p">[</span><span class="n">deque</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">children</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="o">=</span> <span class="p">()</span>
        <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="n">children</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_provenance</span><span class="p">()</span>

<div class="viewcode-block" id="Bundle.update"><a class="viewcode-back" href="../../shed.html#shed.event_streams.Bundle.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">who</span><span class="p">)]</span>
        <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">):</span>
            <span class="c1"># if all the docs are of the same type and not an event, issue</span>
            <span class="c1"># new documents which are combined</span>
            <span class="n">rvs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">):</span>
                <span class="n">first_doc_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">first_doc_name</span> <span class="ow">and</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;event&#39;</span>
                        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">]):</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span>
                        <span class="nb">tuple</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">]))</span>
                    <span class="n">rvs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">any</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;event&#39;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">:</span>
                        <span class="k">while</span> <span class="n">b</span><span class="p">:</span>
                            <span class="n">nd_pair</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="c1"># run the buffers down until no events are left</span>
                            <span class="k">if</span> <span class="n">nd_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;event&#39;</span><span class="p">:</span>
                                <span class="k">break</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">nd_pair</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                                <span class="n">new_nd_pair</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">event</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">refresh_event</span><span class="p">(</span><span class="n">nd_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                                <span class="n">rvs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">new_nd_pair</span><span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;There is a mismatch of docs, but none &quot;</span>
                                       <span class="s2">&quot;of them are events so we have reached &quot;</span>
                                       <span class="s2">&quot;a potential deadlock, so we raise &quot;</span>
                                       <span class="s2">&quot;this error instead&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">rvs</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">condition</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="BundleSingleStream"><a class="viewcode-back" href="../../shed.html#shed.event_streams.BundleSingleStream">[docs]</a><span class="k">class</span> <span class="nc">BundleSingleStream</span><span class="p">(</span><span class="n">EventStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combine multiple headers in a single stream into one</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    child: EventStream instances</span>
<span class="sd">        The event stream containing the data to be zipped together</span>
<span class="sd">    control_stream: {EventStream, int}</span>
<span class="sd">        Information to control the buffering. If int, bundle that many</span>
<span class="sd">        header together. If an EventStream, pull from the start document</span>
<span class="sd">        ``n_hdrs`` to determine the number of headers to bundle</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from shed.utils import to_event_model</span>
<span class="sd">    &gt;&gt;&gt; from streamz import Stream</span>
<span class="sd">    &gt;&gt;&gt; import shed.event_streams as es</span>
<span class="sd">    &gt;&gt;&gt; a = [1, 2, 3]  # base data</span>
<span class="sd">    &gt;&gt;&gt; b = [4, 5, 6]</span>
<span class="sd">    &gt;&gt;&gt; g = to_event_model(a, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; gg = to_event_model(b, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; source = Stream()</span>
<span class="sd">    &gt;&gt;&gt; m = es.BundleSingleStream(source, 2)</span>
<span class="sd">    &gt;&gt;&gt; l = m.sink(print)</span>
<span class="sd">    &gt;&gt;&gt; L = m.sink_to_list()</span>
<span class="sd">    &gt;&gt;&gt; for doc1 in g: zz = source.emit(doc1)</span>
<span class="sd">    &gt;&gt;&gt; for doc2 in gg: z = source.emit(doc2)</span>
<span class="sd">    &gt;&gt;&gt; assert len(L) == 9</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">control_stream</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;maxsize&#39;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desc_start_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">condition</span> <span class="o">=</span> <span class="n">Condition</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prior</span> <span class="o">=</span> <span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">control_stream</span> <span class="o">=</span> <span class="n">control_stream</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">control_stream</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_hdrs</span> <span class="o">=</span> <span class="n">control_stream</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">control_stream</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_hdrs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_provenance</span><span class="p">()</span>

<div class="viewcode-block" id="BundleSingleStream.update"><a class="viewcode-back" href="../../shed.html#shed.event_streams.BundleSingleStream.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">who</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_stream</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_hdrs</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;n_hdrs&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deque</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_hdrs</span><span class="p">:</span>
                <span class="c1"># if all the docs are of the same type and not an event, issue</span>
                <span class="c1"># new documents which are combined</span>
                <span class="n">rvs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">):</span>
                    <span class="n">first_doc_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">first_doc_name</span> <span class="ow">and</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;event&#39;</span>
                            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">]):</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span>
                            <span class="nb">tuple</span><span class="p">([</span><span class="n">b</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">]))</span>
                        <span class="n">rvs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="nb">any</span><span class="p">([</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;event&#39;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">]):</span>
                        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffers</span><span class="p">:</span>
                            <span class="k">while</span> <span class="n">b</span><span class="p">:</span>
                                <span class="n">nd_pair</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="c1"># run the buffers down until no events are left</span>
                                <span class="k">if</span> <span class="n">nd_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;event&#39;</span><span class="p">:</span>
                                    <span class="k">break</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">nd_pair</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                                    <span class="n">new_nd_pair</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">event</span><span class="p">(</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">refresh_event</span><span class="p">(</span><span class="n">nd_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                                    <span class="n">rvs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">new_nd_pair</span><span class="p">))</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                            <span class="s2">&quot;There is a mismatch of docs, but none &quot;</span>
                            <span class="s2">&quot;of them are events so we have reached &quot;</span>
                            <span class="s2">&quot;a potential deadlock, so we raise &quot;</span>
                            <span class="s2">&quot;this error instead&quot;</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">rvs</span></div></div>


<div class="viewcode-block" id="combine_latest"><a class="viewcode-back" href="../../shed.html#shed.event_streams.combine_latest">[docs]</a><span class="k">class</span> <span class="nc">combine_latest</span><span class="p">(</span><span class="n">EventStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combine multiple streams together to a stream of tuples</span>

<span class="sd">    This will emit a new tuple of all of the most recent elements seen from</span>
<span class="sd">    any stream.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    children: EventStream instances</span>
<span class="sd">        The streams to combine</span>
<span class="sd">    emit_on: EventStream, list of EventStreams or None</span>
<span class="sd">        Only emit upon update of the streams listed.</span>
<span class="sd">        If None, emit on update from any stream</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from shed.utils import to_event_model</span>
<span class="sd">    &gt;&gt;&gt; from streamz import Stream</span>
<span class="sd">    &gt;&gt;&gt; import shed.event_streams as es</span>
<span class="sd">    &gt;&gt;&gt; a = [1, 2, 3]  # base data</span>
<span class="sd">    &gt;&gt;&gt; b = [4, 5, 6]</span>
<span class="sd">    &gt;&gt;&gt; g = to_event_model(a, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; gg = to_event_model(b, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; source = Stream()</span>
<span class="sd">    &gt;&gt;&gt; source2 = Stream()</span>
<span class="sd">    &gt;&gt;&gt; m = es.combine_latest(source, source2)</span>
<span class="sd">    &gt;&gt;&gt; l = m.sink(print)</span>
<span class="sd">    &gt;&gt;&gt; L = m.sink_to_list()</span>
<span class="sd">    &gt;&gt;&gt; for doc1 in g: zz = source.emit(doc1)</span>
<span class="sd">    &gt;&gt;&gt; for doc2 in gg: z = source2.emit(doc2)</span>
<span class="sd">    &gt;&gt;&gt; assert len(L) == 6</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">special_docs_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;descriptor&#39;</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">,</span> <span class="n">emit_on</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">children</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">special_last</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">children</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">special_docs_names</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">special_missing</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">special_docs_names</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">emit_on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">emit_on</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
                <span class="n">emit_on</span> <span class="o">=</span> <span class="p">(</span><span class="n">emit_on</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit_on</span> <span class="o">=</span> <span class="n">emit_on</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit_on</span> <span class="o">=</span> <span class="n">children</span>
        <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="n">children</span><span class="p">)</span>

<div class="viewcode-block" id="combine_latest.update"><a class="viewcode-back" href="../../shed.html#shed.event_streams.combine_latest.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">who</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_docs_names</span><span class="p">:</span>
            <span class="n">local_missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_missing</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">local_last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_last</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">local_missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span>
            <span class="n">local_last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last</span>

        <span class="n">local_last</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">local_missing</span> <span class="ow">and</span> <span class="n">who</span> <span class="ow">in</span> <span class="n">local_missing</span><span class="p">:</span>
            <span class="n">local_missing</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">who</span><span class="p">)</span>

        <span class="c1"># we have a document from every one or we are on the emitting stream</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">local_missing</span> <span class="ow">and</span> <span class="n">who</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">emit_on</span><span class="p">:</span>
            <span class="n">tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">local_last</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="zip_latest"><a class="viewcode-back" href="../../shed.html#shed.event_streams.zip_latest">[docs]</a><span class="k">class</span> <span class="nc">zip_latest</span><span class="p">(</span><span class="n">EventStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combine multiple streams together to a stream of tuples</span>

<span class="sd">    This will emit a new tuple of the elements from the lossless stream paired</span>
<span class="sd">    with the latest elements from the other streams.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lossless : EventStream instance</span>
<span class="sd">        The stream who&#39;s documents will always be emitted</span>
<span class="sd">    children: EventStream instances</span>
<span class="sd">        The streams to combine</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from shed.utils import to_event_model</span>
<span class="sd">    &gt;&gt;&gt; from streamz import Stream</span>
<span class="sd">    &gt;&gt;&gt; import shed.event_streams as es</span>
<span class="sd">    &gt;&gt;&gt; a = [1, 2, 3]  # base data</span>
<span class="sd">    &gt;&gt;&gt; b = [4, 5, 6]</span>
<span class="sd">    &gt;&gt;&gt; g = to_event_model(a, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; gg = to_event_model(b, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; source = Stream()</span>
<span class="sd">    &gt;&gt;&gt; source2 = Stream()</span>
<span class="sd">    &gt;&gt;&gt; m = es.zip_latest(source, source2)</span>
<span class="sd">    &gt;&gt;&gt; l = m.sink(print)</span>
<span class="sd">    &gt;&gt;&gt; L = m.sink_to_list()</span>
<span class="sd">    &gt;&gt;&gt; for doc1 in g: zz = source.emit(doc1)</span>
<span class="sd">    &gt;&gt;&gt; for doc2 in gg: z = source2.emit(doc2)</span>
<span class="sd">    &gt;&gt;&gt; assert len(L) == 6</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">special_docs_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;descriptor&#39;</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lossless</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">,</span> <span class="n">clear_on_lossless_stop</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_on_lossless_stop</span> <span class="o">=</span> <span class="n">clear_on_lossless_stop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lossless</span> <span class="o">=</span> <span class="n">lossless</span>
        <span class="n">children</span> <span class="o">=</span> <span class="p">(</span><span class="n">lossless</span><span class="p">,)</span> <span class="o">+</span> <span class="n">children</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">children</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">special_last</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">children</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">special_docs_names</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">special_missing</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">special_docs_names</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lossless_buffer</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
        <span class="c1"># Keep track of the emitted docuement types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lossless_emitted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="n">children</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="zip_latest.update"><a class="viewcode-back" href="../../shed.html#shed.event_streams.zip_latest.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">doc</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">who</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">who</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lossless</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">clear_on_lossless_stop</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">special_last</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">]</span>
                                 <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_docs_names</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">missing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">special_missing</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">special_docs_names</span><span class="p">}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lossless_buffer</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="c1"># Keep track of the emitted docuement types</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lossless_emitted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_docs_names</span><span class="p">:</span>
            <span class="n">local_missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_missing</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">local_last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">special_last</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="n">local_type</span> <span class="o">=</span> <span class="s1">&#39;special&#39;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">local_missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing</span>
            <span class="n">local_last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">last</span>
            <span class="n">local_type</span> <span class="o">=</span> <span class="s1">&#39;event&#39;</span>
            <span class="k">if</span> <span class="n">who</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">lossless</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lossless_buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">local_last</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">local_missing</span> <span class="ow">and</span> <span class="n">who</span> <span class="ow">in</span> <span class="n">local_missing</span><span class="p">:</span>
            <span class="n">local_missing</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">who</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">local_missing</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">local_type</span> <span class="o">==</span> <span class="s1">&#39;special&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lossless_emitted</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="n">local_missing</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lossless</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;stop&#39;</span><span class="p">:</span>
                    <span class="c1"># Clear with each stop doc</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lossless_emitted</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">local_last</span><span class="p">))</span>
            <span class="c1"># check start and descriptors emitted if not buffer</span>
            <span class="k">if</span> <span class="p">{</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;descriptor&#39;</span><span class="p">}</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lossless_emitted</span><span class="p">:</span>
                <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">lossless_buffer</span><span class="p">:</span>
                    <span class="n">local_last</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lossless_buffer</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                    <span class="n">L</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">local_last</span><span class="p">)))</span>
                <span class="k">return</span> <span class="n">L</span></div></div>


<div class="viewcode-block" id="Eventify"><a class="viewcode-back" href="../../shed.html#shed.event_streams.Eventify">[docs]</a><span class="k">class</span> <span class="nc">Eventify</span><span class="p">(</span><span class="n">EventStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate events from data in starts</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    child: EventStream instance</span>
<span class="sd">        The event stream to eventify</span>
<span class="sd">    start_keys: str, optional</span>
<span class="sd">        The run start keys to use to create the events</span>
<span class="sd">        If none supplied, then load all start keys into event</span>
<span class="sd">    output_info: list of tuples, optional</span>
<span class="sd">        describes the resulting stream</span>
<span class="sd">    document : {&#39;start&#39;, &#39;descriptor&#39;, &#39;stop}, optional</span>
<span class="sd">        The document to generate events from. Defaults to &#39;start&#39;</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from shed.utils import to_event_model</span>
<span class="sd">    &gt;&gt;&gt; from streamz import Stream</span>
<span class="sd">    &gt;&gt;&gt; import shed.event_streams as es</span>
<span class="sd">    &gt;&gt;&gt; a = [1, 2, 3]  # base data</span>
<span class="sd">    &gt;&gt;&gt; g = to_event_model(a, [(&#39;det&#39;, {&#39;dtype&#39;: &#39;float&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; source = Stream()</span>
<span class="sd">    &gt;&gt;&gt; m = es.Eventify(source, &#39;uid&#39;,</span>
<span class="sd">    ...     output_info=[(&#39;start_uid&#39;, {&#39;dtype&#39;: &#39;str&#39;})])</span>
<span class="sd">    &gt;&gt;&gt; l = m.sink(print)</span>
<span class="sd">    &gt;&gt;&gt; L = m.sink_to_list()</span>
<span class="sd">    &gt;&gt;&gt; for doc1 in g:</span>
<span class="sd">    ...     zz = source.emit(doc1)</span>
<span class="sd">    &gt;&gt;&gt; assert len(L) == 4</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">,</span> <span class="n">output_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">document</span><span class="o">=</span><span class="s1">&#39;start&#39;</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># TODO: maybe allow start_key to be a list of relevent keys?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keys</span> <span class="o">=</span> <span class="n">keys</span>
        <span class="k">if</span> <span class="n">document</span> <span class="o">==</span> <span class="s1">&#39;event&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can&#39;t eventify event, its an event already&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">document</span> <span class="o">=</span> <span class="n">document</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit_event</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unseen_docs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;descriptor&#39;</span><span class="p">,</span> <span class="s1">&#39;event&#39;</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">]</span>

        <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">output_info</span><span class="o">=</span><span class="n">output_info</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_update_initial_state_helper</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;keys&#39;</span><span class="p">,</span> <span class="s1">&#39;document&#39;</span><span class="p">,</span> <span class="s1">&#39;vals&#39;</span><span class="p">,</span> <span class="s1">&#39;emit_event&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;unseen_docs&#39;</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_extract_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="c1"># If there are no start keys, then use all the keys</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">docs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">docs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">key</span><span class="p">])</span>

        <span class="c1"># If no output info provided use all the start keys</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">output_info</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_info</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_info</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_info</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The output_info does not match the values&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Eventify.update"><a class="viewcode-back" href="../../shed.html#shed.event_streams.Eventify.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curate_streams</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unseen_docs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">document</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_extract_info</span><span class="p">(</span><span class="n">docs</span><span class="p">)</span>
                <span class="n">rv</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">residual_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">unseen_docs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">residual_name</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
                        <span class="c1"># Don&#39;t clear the start yet</span>
                        <span class="n">rv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="kc">False</span><span class="p">)))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rv</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="p">((</span><span class="n">residual_name</span><span class="p">,</span> <span class="n">docs</span><span class="p">))))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unseen_docs</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">rv</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unseen_docs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unseen_docs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">docs</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Eventify.event"><a class="viewcode-back" href="../../shed.html#shed.event_streams.Eventify.event">[docs]</a>    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">emit_event</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit_event</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">event</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">issue_event</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vals</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="Query"><a class="viewcode-back" href="../../shed.html#shed.event_streams.Query">[docs]</a><span class="k">class</span> <span class="nc">Query</span><span class="p">(</span><span class="n">EventStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Query a databroker for data</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    db: databroker.Broker instance</span>
<span class="sd">        The databroker to be queried</span>
<span class="sd">    child: EventStream instance</span>
<span class="sd">        The stream to be subscribed to</span>
<span class="sd">    query_function: callable</span>
<span class="sd">        A function which executes a query against the databroker using the</span>
<span class="sd">        start document of the stream. Note that the signature must be</span>
<span class="sd">        ``func(Broker, docs)`` where docs is a tuple of documents and returns</span>
<span class="sd">        the valid headers.</span>
<span class="sd">    query_decider: callable, optional</span>
<span class="sd">        A function to decide among the query results. The signature must be</span>
<span class="sd">        func(list of headers, docs) and returns a single header. If not</span>
<span class="sd">        provided use all the headers returned. Defaults to None. Note that the</span>
<span class="sd">        query_decider must return an iterable.</span>
<span class="sd">    max_n_hdrs: int, optional</span>
<span class="sd">        Maximum number of headers returned, if the number of headers returned</span>
<span class="sd">        is greater than the max then the node raises a RuntimeError</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">query_function</span><span class="p">,</span>
                 <span class="n">query_decider</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_n_hdrs</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_n_hdrs</span> <span class="o">=</span> <span class="n">max_n_hdrs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="n">db</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query_function</span> <span class="o">=</span> <span class="n">query_function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">query_decider</span> <span class="o">=</span> <span class="n">query_decider</span>
        <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span>
                             <span class="n">output_info</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;hdr_uid&#39;</span><span class="p">,</span>
                                           <span class="p">{</span><span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;str&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="s1">&#39;query&#39;</span><span class="p">})],</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_provenance</span><span class="p">(</span><span class="n">query_function</span><span class="o">=</span><span class="n">query_function</span><span class="p">,</span>
                                 <span class="n">query_decider</span><span class="o">=</span><span class="n">query_decider</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_update_initial_state_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                                <span class="p">[</span><span class="s1">&#39;uids&#39;</span><span class="p">,</span>
                                                                 <span class="p">]))</span>

<div class="viewcode-block" id="Query.start"><a class="viewcode-back" href="../../shed.html#shed.event_streams.Query.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
        <span class="c1"># XXX: If we don&#39;t have a decider we return all the results</span>
        <span class="c1"># TODO: should this issue a stop on failure?</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">,</span> <span class="n">docs</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_decider</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query_decider</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">docs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">uids</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span>
                <span class="n">r</span><span class="o">.</span><span class="n">stream</span><span class="p">(</span><span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)))[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;uid&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_n_hdrs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Query returned more headers than the max &quot;</span>
                                   <span class="s2">&quot;number of headers, either your query was &quot;</span>
                                   <span class="s2">&quot;too broad or you need to up the &quot;</span>
                                   <span class="s2">&quot;max_n_hdrs.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">md</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">n_hdrs</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uids</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="Query.update"><a class="viewcode-back" href="../../shed.html#shed.event_streams.Query.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curate_streams</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
            <span class="n">el</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">docs</span><span class="p">)),</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">(</span><span class="n">docs</span><span class="p">))]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uids</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">uids</span><span class="p">:</span>
                    <span class="n">el</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">event</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">issue_event</span><span class="p">(</span><span class="n">u</span><span class="p">))))</span>
            <span class="n">el</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="n">docs</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">el</span></div></div>


<div class="viewcode-block" id="QueryUnpacker"><a class="viewcode-back" href="../../shed.html#shed.event_streams.QueryUnpacker">[docs]</a><span class="k">class</span> <span class="nc">QueryUnpacker</span><span class="p">(</span><span class="n">EventStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Unpack Queries from the Query node</span>

<span class="sd">    This unpacks the start uids passed down from the Query node and creates</span>
<span class="sd">    a restream of the data for each header</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    db: databroker.Broker instance</span>
<span class="sd">        The databroker to be queried</span>
<span class="sd">    child: EventStream instance</span>
<span class="sd">        The stream to be subscribed to</span>
<span class="sd">    fill: bool, optional</span>
<span class="sd">        Whether or not to fill the documents, defaults to True</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="n">db</span>
        <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_update_initial_state_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                                                <span class="p">[</span><span class="s1">&#39;fill&#39;</span><span class="p">,</span> <span class="p">]))</span>

<div class="viewcode-block" id="QueryUnpacker.update"><a class="viewcode-back" href="../../shed.html#shed.event_streams.QueryUnpacker.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curate_streams</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear</span><span class="p">()</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">docs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;event&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">nd</span><span class="p">)</span> <span class="k">for</span> <span class="n">nd</span> <span class="ow">in</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="p">[</span><span class="n">doc</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="s1">&#39;hdr_uid&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">documents</span><span class="p">(</span><span class="n">fill</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">)]</span></div></div>


<div class="viewcode-block" id="split"><a class="viewcode-back" href="../../shed.html#shed.event_streams.split">[docs]</a><span class="k">class</span> <span class="nc">split</span><span class="p">(</span><span class="n">EventStream</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">n_streams</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">split_streams</span> <span class="o">=</span> <span class="p">[</span><span class="n">EventStream</span><span class="p">(</span>
            <span class="n">stream_name</span><span class="o">=</span><span class="s1">&#39;Split output-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_streams</span><span class="p">)]</span>
        <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">)</span>

<div class="viewcode-block" id="split.update"><a class="viewcode-back" href="../../shed.html#shed.event_streams.split.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">name</span><span class="p">,</span> <span class="n">docs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curate_streams</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">emit</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">doc</span><span class="p">))</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">zzip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_streams</span><span class="p">,</span>
                                                       <span class="n">docs</span><span class="p">)]</span></div></div>


<div class="viewcode-block" id="fill_events"><a class="viewcode-back" href="../../shed.html#shed.event_streams.fill_events">[docs]</a><span class="k">class</span> <span class="nc">fill_events</span><span class="p">(</span><span class="n">EventStream</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fill events without provenence&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="n">db</span>
        <span class="n">EventStream</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="o">=</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descs</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="fill_events.start"><a class="viewcode-back" href="../../shed.html#shed.event_streams.fill_events.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="n">docs</span></div>

<div class="viewcode-block" id="fill_events.descriptor"><a class="viewcode-back" href="../../shed.html#shed.event_streams.fill_events.descriptor">[docs]</a>    <span class="k">def</span> <span class="nf">descriptor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descs</span> <span class="o">=</span> <span class="n">docs</span>
        <span class="k">return</span> <span class="s1">&#39;descriptor&#39;</span><span class="p">,</span> <span class="n">docs</span></div>

<div class="viewcode-block" id="fill_events.event"><a class="viewcode-back" href="../../shed.html#shed.event_streams.fill_events.event">[docs]</a>    <span class="k">def</span> <span class="nf">event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">fill_events</span><span class="p">(</span><span class="n">docs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">descs</span><span class="p">))</span>
        <span class="k">return</span> <span class="s1">&#39;event&#39;</span><span class="p">,</span> <span class="n">d</span></div>

<div class="viewcode-block" id="fill_events.stop"><a class="viewcode-back" href="../../shed.html#shed.event_streams.fill_events.stop">[docs]</a>    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">docs</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;stop&#39;</span><span class="p">,</span> <span class="n">docs</span></div></div>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Author.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>